
Mocking in Go: Using interfaces for fun and profits

10 Oct 2014

Gabriel Aszalos
Gopher, Freelancer
@gabrielaszalos
gabriel.aszalos@gmail.com
http://github.com/gbbr

* How to write software

- Readability
- Testability (isolation & decoupling)
- Efficiency

* Benefits of focusing on testability

- Scalability - isolated components are easy to scale independently.
- User Perspective - view things from the other side of the fence.
- Code Coverage - ensures integrity.
- Stability and Security

* Mailing exchange server (Gomez)

- SMTP receives mail
- MTA (Mail Transfer Agent) delivers mail
- POP3 retrieves mail
- _Optional_: JSON API
- _Optional_: CLI

* Mailbox

Central pivot of the mail exchange server. Queues, retrieves and delivers messages to local inboxes.

	type Mailbox interface {
		// Queues a message for delivery
		Queue(msg *mail.Message) error

		// Retrieve a message from the top of the queue
		Dequeue() (*mail.Message, error)

		// Delivers a message to a users inbox
		Deliver(msg *mail.Message, addr *mail.Address) error

		// Retrieves a userâ€™s messages
		Retrieve(usr User) []*mail.Message

		// Queries the mailbox for a user
		Query(addr *mail.Address) QueryStatus
	}

* Multiple implementations

- PostBox - PostgreSQL implementation
- RedBox - Redis implementation
- MongoBox - MongoDB implementation

* Mocking a mailbox

	type MockMailbox struct {
		QueueFn    func(msg *mail.Message) error
		DequeueFn  func() (*mail.Message, error)
		DeliverFn  func(msg *mail.Message, addr *mail.Address) error
		RetrieveFn func(usr User) []*mail.Message
		QueryFn    func(addr *mail.Address) QueryStatus	
	}

	func (m *MockMailbox) Queue(msg *mail.Message) error        { return m.QueueFn(msg)    }
	func (m *MockMailbox) Dequeue() (*mail.Message, error)      { return m.DequeueFn()     }
	func (m *MockMailbox) Retrieve(usr User) []*mailMessage     { return m.RetrieveFn(usr) }
	func (m *MockMailbox) Query(addr *mail.Address) QueryStatus { return m.QueryFn(addr)   }

	func (m *MockMailbox) Deliver(msg *mail.Message, addr *mail.Address) error {
		return m.DeliverFn(msg, addr)
	}

* Faking a network address

- net.Addr is an interface (golang.org/pkg/net/#Addr) that implements two methods.

	type MockAddr struct {
		Net, Addr string
	}

	func (m MockAddr) Network() string { return m.Net  }
	func (m MockAddr) String()  string { return m.Addr }

* Faking a network connection

- A network connection (net.Conn) is an interface (golang.org/pkg/net/#Conn)

	type MockConn struct {
		LocalNet, LocalAddr   string        // Local address
		RemoteNet, RemoteAddr string        // Remote address
		Incoming, Outgoing    *bytes.Buffer // Read/write buffers
	}

	func (c Conn) LocalAddr() net.Addr {
		return &MockAddr{c.LocalNetwork, c.LocalAddress}
	}

	func (c Conn) RemoteAddr() net.Addr {
		return &MockAddr{c.RemoteNetwork, c.RemoteAddress}
	}

	func (c *Conn) Read (b []byte) (n int, err error) { return c.Outgoing.Read(b)  }
	func (c *Conn) Write(b []byte) (n int, err error) { return c.Incoming.Write(b) }

	func (c Conn) Close() error                       { return nil }
	func (c Conn) SetDeadline(t time.Time) error      { return nil }
	func (c Conn) SetReadDeadline(t time.Time) error  { return nil }
	func (c Conn) SetWriteDeadline(t time.Time) error { return nil }


* Faking time

* Ensuring interfaces are implemented

	var (
		_ Mailbox = new(MockMailbox)
		_ net.Conn = new(MockConn)
		_ net.Addr = new(MockAddr)
	)

* Tips & Tricks

Generate a coverage output:

	$ go test -coverprofile=cov.out [package]

Generate a heat-map output:

	$ go test -covermode=count -coverprofile=cov.out [package]

View a coverage file:

	$ go tool cover -html=cov.out
